# 1. 딕셔너리는 순서를 보장하지 않는다. 

​																					(SWEA  - 6485 - 삼성시의 버스 노선)

```
- 내 생각 : 정류장 번호를 딕셔너리 key값으로 input() 받고 value에 카운트를 늘려가는 식으로 풀이를 진행했는데, 딕셔너리 출력은 내가 input()받은 순서를 보장해주지 않기 때문에 실패했었다.  
- 해결책 : 그래서 딕셔너리같은 느낌으로 key값을 담은 리스트와 value값을 담은 리스트를 따로 만들어서 해결하였다! 순서보장!!
```

​																				

# 2. 전체 경우의 수를 잘 파악해야 한다.

​																					(백준 - 1018 - 체스판 다시 칠하기)

- 내 생각 : 

  BWBWBWBW 와 같이 검정색과 흰색이 번갈아 나오는 격자판에서 몇몇 네모가 BW 순서에 맞지 않게 잘못 칠해져 있어서 다시 칠해야하는 네모의 최소 개수를 구하는 문제였다. 나는 B로 시작하는 2차원 배열을 만들고 W로 시작하는 2차원 배열을 만들어서 비교해가며 최소값을 구하는 형태로 문제풀이를 진행했다. 

  문제점은 B로 시작한다고 B로 시작하는 배열이랑만 비교하고 W로 시작한다고 W로 시작하는 배열이랑만 비교했다는 점이다.     

```	python
    if ARR[row][col] == 'B': # 처음 시작이 B인경우     	     
    		for i in range(8):
        	        for j in range(8):
        	            if ARR[row+i][col+j] != black_first[i][j]:
    	                    cnt += 1
	elif ARR[row][col] == 'W': # 처음 시작이 W인경우
           	 for i in range(8):
           	     for j in range(8): 
        	            if ARR[row+i][col+j] != white_first[i][j]:
    	                    cnt += 1
	cnt_list.append(cnt)

print(min(cnt_list))
```

- 해결책 : 

  B로 시작하는 격자와 W로 시작하는 격자 각각 비교하고 최소값을 받아서 비교하기!

```python
    for j in range(8):
        if ARR[row+i][col+j] != black_first[i][j]:
            black_cnt += 1
        if ARR[row+i][col+j] != white_first[i][j]:
            white_cnt += 1
	cnt_list.append(min(black_cnt,white_cnt))
print(min(cnt_list))
```

